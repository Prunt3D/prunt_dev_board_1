pragma Style_Checks (Off);
--  Code automatically generated by asn1scc tool
pragma Warnings (Off, "no entities of ""Interfaces"" are referenced");
with Interfaces;
pragma Warnings (On, "no entities of ""Interfaces"" are referenced");

pragma Warnings (Off, "use clause for package ""Interfaces"" has no effect");
use Interfaces;
pragma Warnings (On, "use clause for package ""Interfaces"" has no effect");

with adaasn1rtl;
pragma Warnings (Off, "unit ""adaasn1rtl.encoding"" is not referenced");
with adaasn1rtl.encoding;
pragma Warnings (On, "unit ""adaasn1rtl.encoding"" is not referenced");


pragma Warnings (Off, "unit ""System"" is not referenced");
with System;
pragma Warnings (On, "unit ""System"" is not referenced");

pragma Warnings (Off, "use clause for package ""adaasn1rtl"" has no effect");
use adaasn1rtl;
pragma Warnings (On, "use clause for package ""adaasn1rtl"" has no effect");

pragma Warnings (Off, "use clause for type");
pragma Warnings (Off, "is already use-visible through package use clause at line");
use type adaasn1rtl.OctetBuffer;
use type adaasn1rtl.BitArray;
use type adaasn1rtl.Asn1UInt;
use type adaasn1rtl.Asn1Int;
use type adaasn1rtl.BIT;
pragma Warnings (On, "use clause for type");
pragma Warnings (On, "is already use-visible through package use clause at line");



package MCU_COMMS with SPARK_Mode
is


-- Setup_Type --------------------------------------------
subtype Setup_Type_version is Interfaces.Unsigned_16 range 0 .. 65535;


type Setup_Type is record
    version : Setup_Type_version;
end record;


function Setup_Type_version_Equal(val1, val2 : Setup_Type_version) return Boolean;

function Setup_Type_Equal(val1, val2 : Setup_Type) return Boolean;

ERR_SETUP_TYPE_VERSION:constant Integer := 1; -- (0 .. 65535)
function Setup_Type_version_IsConstraintValid(val : Setup_Type_version) return adaasn1rtl.ASN1_RESULT;

ERR_SETUP_TYPE:constant Integer := 6; --
function Setup_Type_IsConstraintValid(val : Setup_Type) return adaasn1rtl.ASN1_RESULT;

function Setup_Type_version_Init  return Setup_Type_version is
(0);
function Setup_Type_Init  return Setup_Type is
((version => 0));

ERR_ACN_ENCODE_SETUP_TYPE:constant Integer := 9;
ERR_ACN_ENCODE_SETUP_TYPE_VERSION:constant Integer := 4;
Setup_Type_REQUIRED_BYTES_FOR_ACN_ENCODING:constant Integer := 2;
Setup_Type_REQUIRED_BITS_FOR_ACN_ENCODING:constant Integer := 16;

subtype Setup_Type_ACN_Stream is adaasn1rtl.encoding.Bitstream(Setup_Type_REQUIRED_BYTES_FOR_ACN_ENCODING);

procedure Setup_Type_ACN_Encode(val : Setup_Type; Stream : out Setup_Type_ACN_Stream; result : OUT adaasn1rtl.ASN1_RESULT);

procedure Setup_Type_ACN_Encode_aux(val : Setup_Type; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
with
    Pre => bs.Current_Bit_Pos < Natural'Last - Setup_Type_REQUIRED_BITS_FOR_ACN_ENCODING
      and then bs.Size_In_Bytes < Positive'Last / 8
      and then bs.Current_Bit_Pos + Setup_Type_REQUIRED_BITS_FOR_ACN_ENCODING <= bs.Size_In_Bytes * 8,
       Post =>
         (result.Success and bs.Current_Bit_Pos >= bs'Old.Current_Bit_Pos and bs.Current_Bit_Pos <= bs'Old.Current_Bit_Pos + Setup_Type_REQUIRED_BITS_FOR_ACN_ENCODING)
       or
         not result.Success
;



ERR_ACN_DECODE_SETUP_TYPE:constant Integer := 10;
ERR_ACN_DECODE_SETUP_TYPE_VERSION:constant Integer := 5;
procedure Setup_Type_ACN_Decode(val: out Setup_Type; Stream : in out Setup_Type_ACN_Stream; result : OUT adaasn1rtl.ASN1_RESULT);

procedure Setup_Type_ACN_Decode_aux(val:out Setup_Type; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
with
    Pre => bs.Current_Bit_Pos < Natural'Last - Setup_Type_REQUIRED_BITS_FOR_ACN_ENCODING
      and then bs.Size_In_Bytes < Positive'Last / 8
      and then bs.Current_Bit_Pos + Setup_Type_REQUIRED_BITS_FOR_ACN_ENCODING <= bs.Size_In_Bytes * 8,
       Post =>
         (result.Success and bs.Current_Bit_Pos >= bs'Old.Current_Bit_Pos and bs.Current_Bit_Pos <= bs'Old.Current_Bit_Pos + Setup_Type_REQUIRED_BITS_FOR_ACN_ENCODING)
       or
         not result.Success
;
-- Inputs_Type --------------------------------------------
-- Inputs_Type_stepper_fault --------------------------------------------


subtype Inputs_Type_stepper_fault_index is Integer range 1..6;
type Inputs_Type_stepper_fault_array is array (Inputs_Type_stepper_fault_index) of adaasn1rtl.Asn1Boolean;
type Inputs_Type_stepper_fault is  record
    Data  : Inputs_Type_stepper_fault_array;
end record;
subtype Inputs_Type_adc_sequential_id is Interfaces.Unsigned_16 range 0 .. 65535;

-- Inputs_Type_adc_temp_value --------------------------------------------

subtype Inputs_Type_adc_temp_value_elem is Interfaces.Unsigned_16 range 0 .. 65535;


subtype Inputs_Type_adc_temp_value_index is Integer range 1..4;
type Inputs_Type_adc_temp_value_array is array (Inputs_Type_adc_temp_value_index) of Inputs_Type_adc_temp_value_elem;
type Inputs_Type_adc_temp_value is  record
    Data  : Inputs_Type_adc_temp_value_array;
end record;
-- Inputs_Type_fan_tach_count --------------------------------------------

subtype Inputs_Type_fan_tach_count_elem is Interfaces.Unsigned_16 range 0 .. 65535;


subtype Inputs_Type_fan_tach_count_index is Integer range 1..4;
type Inputs_Type_fan_tach_count_array is array (Inputs_Type_fan_tach_count_index) of Inputs_Type_fan_tach_count_elem;
type Inputs_Type_fan_tach_count is  record
    Data  : Inputs_Type_fan_tach_count_array;
end record;

type Inputs_Type is record
    stepper_fault : Inputs_Type_stepper_fault;
    adc_sequential_id : Inputs_Type_adc_sequential_id;
    adc_temp_value : Inputs_Type_adc_temp_value;
    fan_tach_count : Inputs_Type_fan_tach_count;
end record;


function Inputs_Type_stepper_fault_Equal(val1, val2 : Inputs_Type_stepper_fault) return Boolean;

function Inputs_Type_adc_sequential_id_Equal(val1, val2 : Inputs_Type_adc_sequential_id) return Boolean;

function Inputs_Type_adc_temp_value_elem_Equal(val1, val2 : Inputs_Type_adc_temp_value_elem) return Boolean;

function Inputs_Type_adc_temp_value_Equal(val1, val2 : Inputs_Type_adc_temp_value) return Boolean;

function Inputs_Type_fan_tach_count_elem_Equal(val1, val2 : Inputs_Type_fan_tach_count_elem) return Boolean;

function Inputs_Type_fan_tach_count_Equal(val1, val2 : Inputs_Type_fan_tach_count) return Boolean;

function Inputs_Type_Equal(val1, val2 : Inputs_Type) return Boolean;

ERR_INPUTS_TYPE_STEPPER_FAULT:constant Integer := 16; -- (SIZE (6))
ERR_INPUTS_TYPE_STEPPER_FAULT_ELM:constant Integer := 11; --
function Inputs_Type_stepper_fault_IsConstraintValid(val : Inputs_Type_stepper_fault) return adaasn1rtl.ASN1_RESULT;

ERR_INPUTS_TYPE_ADC_SEQUENTIAL_ID:constant Integer := 21; -- (0 .. 65535)
function Inputs_Type_adc_sequential_id_IsConstraintValid(val : Inputs_Type_adc_sequential_id) return adaasn1rtl.ASN1_RESULT;

ERR_INPUTS_TYPE_ADC_TEMP_VALUE_ELM:constant Integer := 26; -- (0 .. 65535)
function Inputs_Type_adc_temp_value_elem_IsConstraintValid(val : Inputs_Type_adc_temp_value_elem) return adaasn1rtl.ASN1_RESULT;

ERR_INPUTS_TYPE_ADC_TEMP_VALUE:constant Integer := 31; -- (SIZE (4))
function Inputs_Type_adc_temp_value_IsConstraintValid(val : Inputs_Type_adc_temp_value) return adaasn1rtl.ASN1_RESULT;

ERR_INPUTS_TYPE_FAN_TACH_COUNT_ELM:constant Integer := 36; -- (0 .. 65535)
function Inputs_Type_fan_tach_count_elem_IsConstraintValid(val : Inputs_Type_fan_tach_count_elem) return adaasn1rtl.ASN1_RESULT;

ERR_INPUTS_TYPE_FAN_TACH_COUNT:constant Integer := 41; -- (SIZE (4))
function Inputs_Type_fan_tach_count_IsConstraintValid(val : Inputs_Type_fan_tach_count) return adaasn1rtl.ASN1_RESULT;

ERR_INPUTS_TYPE:constant Integer := 46; --
function Inputs_Type_IsConstraintValid(val : Inputs_Type) return adaasn1rtl.ASN1_RESULT;

function Inputs_Type_stepper_fault_Init  return Inputs_Type_stepper_fault is
((Data => (others => False)));
function Inputs_Type_adc_sequential_id_Init  return Inputs_Type_adc_sequential_id is
(0);
function Inputs_Type_adc_temp_value_elem_Init  return Inputs_Type_adc_temp_value_elem is
(0);
function Inputs_Type_adc_temp_value_Init  return Inputs_Type_adc_temp_value is
((Data => (others => 0)));
function Inputs_Type_fan_tach_count_elem_Init  return Inputs_Type_fan_tach_count_elem is
(0);
function Inputs_Type_fan_tach_count_Init  return Inputs_Type_fan_tach_count is
((Data => (others => 0)));
function Inputs_Type_Init  return Inputs_Type is
((stepper_fault => Inputs_Type_stepper_fault_Init, adc_sequential_id => 0, adc_temp_value => Inputs_Type_adc_temp_value_Init, fan_tach_count => Inputs_Type_fan_tach_count_Init));

ERR_ACN_ENCODE_INPUTS_TYPE:constant Integer := 49;
ERR_ACN_ENCODE_INPUTS_TYPE_STEPPER_FAULT:constant Integer := 19;
ERR_ACN_ENCODE_INPUTS_TYPE_STEPPER_FAULT_ELM:constant Integer := 14;
ERR_ACN_ENCODE_INPUTS_TYPE_ADC_SEQUENTIAL_ID:constant Integer := 24;
ERR_ACN_ENCODE_INPUTS_TYPE_ADC_TEMP_VALUE:constant Integer := 34;
ERR_ACN_ENCODE_INPUTS_TYPE_ADC_TEMP_VALUE_ELM:constant Integer := 29;
ERR_ACN_ENCODE_INPUTS_TYPE_FAN_TACH_COUNT:constant Integer := 44;
ERR_ACN_ENCODE_INPUTS_TYPE_FAN_TACH_COUNT_ELM:constant Integer := 39;
Inputs_Type_REQUIRED_BYTES_FOR_ACN_ENCODING:constant Integer := 19;
Inputs_Type_REQUIRED_BITS_FOR_ACN_ENCODING:constant Integer := 150;

subtype Inputs_Type_ACN_Stream is adaasn1rtl.encoding.Bitstream(Inputs_Type_REQUIRED_BYTES_FOR_ACN_ENCODING);

procedure Inputs_Type_ACN_Encode(val : Inputs_Type; Stream : out Inputs_Type_ACN_Stream; result : OUT adaasn1rtl.ASN1_RESULT);

procedure Inputs_Type_ACN_Encode_aux(val : Inputs_Type; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
with
    Pre => bs.Current_Bit_Pos < Natural'Last - Inputs_Type_REQUIRED_BITS_FOR_ACN_ENCODING
      and then bs.Size_In_Bytes < Positive'Last / 8
      and then bs.Current_Bit_Pos + Inputs_Type_REQUIRED_BITS_FOR_ACN_ENCODING <= bs.Size_In_Bytes * 8,
       Post =>
         (result.Success and bs.Current_Bit_Pos >= bs'Old.Current_Bit_Pos and bs.Current_Bit_Pos <= bs'Old.Current_Bit_Pos + Inputs_Type_REQUIRED_BITS_FOR_ACN_ENCODING)
       or
         not result.Success
;



ERR_ACN_DECODE_INPUTS_TYPE:constant Integer := 50;
ERR_ACN_DECODE_INPUTS_TYPE_STEPPER_FAULT:constant Integer := 20;
ERR_ACN_DECODE_INPUTS_TYPE_STEPPER_FAULT_ELM:constant Integer := 15;
ERR_ACN_DECODE_INPUTS_TYPE_ADC_SEQUENTIAL_ID:constant Integer := 25;
ERR_ACN_DECODE_INPUTS_TYPE_ADC_TEMP_VALUE:constant Integer := 35;
ERR_ACN_DECODE_INPUTS_TYPE_ADC_TEMP_VALUE_ELM:constant Integer := 30;
ERR_ACN_DECODE_INPUTS_TYPE_FAN_TACH_COUNT:constant Integer := 45;
ERR_ACN_DECODE_INPUTS_TYPE_FAN_TACH_COUNT_ELM:constant Integer := 40;
procedure Inputs_Type_ACN_Decode(val: out Inputs_Type; Stream : in out Inputs_Type_ACN_Stream; result : OUT adaasn1rtl.ASN1_RESULT);

procedure Inputs_Type_ACN_Decode_aux(val:out Inputs_Type; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
with
    Pre => bs.Current_Bit_Pos < Natural'Last - Inputs_Type_REQUIRED_BITS_FOR_ACN_ENCODING
      and then bs.Size_In_Bytes < Positive'Last / 8
      and then bs.Current_Bit_Pos + Inputs_Type_REQUIRED_BITS_FOR_ACN_ENCODING <= bs.Size_In_Bytes * 8,
       Post =>
         (result.Success and bs.Current_Bit_Pos >= bs'Old.Current_Bit_Pos and bs.Current_Bit_Pos <= bs'Old.Current_Bit_Pos + Inputs_Type_REQUIRED_BITS_FOR_ACN_ENCODING)
       or
         not result.Success
;
-- Outputs_Type --------------------------------------------
-- Outputs_Type_stepper_output_enable --------------------------------------------


subtype Outputs_Type_stepper_output_enable_index is Integer range 1..6;
type Outputs_Type_stepper_output_enable_array is array (Outputs_Type_stepper_output_enable_index) of adaasn1rtl.Asn1Boolean;
type Outputs_Type_stepper_output_enable is  record
    Data  : Outputs_Type_stepper_output_enable_array;
end record;
-- Outputs_Type_stepper_enable --------------------------------------------


subtype Outputs_Type_stepper_enable_index is Integer range 1..6;
type Outputs_Type_stepper_enable_array is array (Outputs_Type_stepper_enable_index) of adaasn1rtl.Asn1Boolean;
type Outputs_Type_stepper_enable is  record
    Data  : Outputs_Type_stepper_enable_array;
end record;
-- Outputs_Type_fan_pwm --------------------------------------------

subtype Outputs_Type_fan_pwm_elem is Interfaces.Unsigned_16 range 0 .. 639;


subtype Outputs_Type_fan_pwm_index is Integer range 1..4;
type Outputs_Type_fan_pwm_array is array (Outputs_Type_fan_pwm_index) of Outputs_Type_fan_pwm_elem;
type Outputs_Type_fan_pwm is  record
    Data  : Outputs_Type_fan_pwm_array;
end record;

type Outputs_Type is record
    heater_enable : adaasn1rtl.Asn1Boolean;
    stepper_output_enable : Outputs_Type_stepper_output_enable;
    stepper_enable : Outputs_Type_stepper_enable;
    fan_pwm : Outputs_Type_fan_pwm;
end record;


function Outputs_Type_stepper_output_enable_Equal(val1, val2 : Outputs_Type_stepper_output_enable) return Boolean;

function Outputs_Type_stepper_enable_Equal(val1, val2 : Outputs_Type_stepper_enable) return Boolean;

function Outputs_Type_fan_pwm_elem_Equal(val1, val2 : Outputs_Type_fan_pwm_elem) return Boolean;

function Outputs_Type_fan_pwm_Equal(val1, val2 : Outputs_Type_fan_pwm) return Boolean;

function Outputs_Type_Equal(val1, val2 : Outputs_Type) return Boolean;

ERR_OUTPUTS_TYPE_STEPPER_OUTPUT_ENABLE:constant Integer := 61; -- (SIZE (6))
ERR_OUTPUTS_TYPE_STEPPER_OUTPUT_ENABLE_ELM:constant Integer := 56; --
function Outputs_Type_stepper_output_enable_IsConstraintValid(val : Outputs_Type_stepper_output_enable) return adaasn1rtl.ASN1_RESULT;

ERR_OUTPUTS_TYPE_STEPPER_ENABLE:constant Integer := 71; -- (SIZE (6))
ERR_OUTPUTS_TYPE_STEPPER_ENABLE_ELM:constant Integer := 66; --
function Outputs_Type_stepper_enable_IsConstraintValid(val : Outputs_Type_stepper_enable) return adaasn1rtl.ASN1_RESULT;

ERR_OUTPUTS_TYPE_FAN_PWM_ELM:constant Integer := 76; -- (0 .. 639)
function Outputs_Type_fan_pwm_elem_IsConstraintValid(val : Outputs_Type_fan_pwm_elem) return adaasn1rtl.ASN1_RESULT;

ERR_OUTPUTS_TYPE_FAN_PWM:constant Integer := 81; -- (SIZE (4))
function Outputs_Type_fan_pwm_IsConstraintValid(val : Outputs_Type_fan_pwm) return adaasn1rtl.ASN1_RESULT;

ERR_OUTPUTS_TYPE:constant Integer := 86; --
ERR_OUTPUTS_TYPE_HEATER_ENABLE:constant Integer := 51; --
function Outputs_Type_IsConstraintValid(val : Outputs_Type) return adaasn1rtl.ASN1_RESULT;

function Outputs_Type_stepper_output_enable_Init  return Outputs_Type_stepper_output_enable is
((Data => (others => False)));
function Outputs_Type_stepper_enable_Init  return Outputs_Type_stepper_enable is
((Data => (others => False)));
function Outputs_Type_fan_pwm_elem_Init  return Outputs_Type_fan_pwm_elem is
(0);
function Outputs_Type_fan_pwm_Init  return Outputs_Type_fan_pwm is
((Data => (others => 0)));
function Outputs_Type_Init  return Outputs_Type is
((heater_enable => False, stepper_output_enable => Outputs_Type_stepper_output_enable_Init, stepper_enable => Outputs_Type_stepper_enable_Init, fan_pwm => Outputs_Type_fan_pwm_Init));

ERR_ACN_ENCODE_OUTPUTS_TYPE:constant Integer := 89;
ERR_ACN_ENCODE_OUTPUTS_TYPE_HEATER_ENABLE:constant Integer := 54;
ERR_ACN_ENCODE_OUTPUTS_TYPE_STEPPER_OUTPUT_ENABLE:constant Integer := 64;
ERR_ACN_ENCODE_OUTPUTS_TYPE_STEPPER_OUTPUT_ENABLE_ELM:constant Integer := 59;
ERR_ACN_ENCODE_OUTPUTS_TYPE_STEPPER_ENABLE:constant Integer := 74;
ERR_ACN_ENCODE_OUTPUTS_TYPE_STEPPER_ENABLE_ELM:constant Integer := 69;
ERR_ACN_ENCODE_OUTPUTS_TYPE_FAN_PWM:constant Integer := 84;
ERR_ACN_ENCODE_OUTPUTS_TYPE_FAN_PWM_ELM:constant Integer := 79;
Outputs_Type_REQUIRED_BYTES_FOR_ACN_ENCODING:constant Integer := 7;
Outputs_Type_REQUIRED_BITS_FOR_ACN_ENCODING:constant Integer := 53;

subtype Outputs_Type_ACN_Stream is adaasn1rtl.encoding.Bitstream(Outputs_Type_REQUIRED_BYTES_FOR_ACN_ENCODING);

procedure Outputs_Type_ACN_Encode(val : Outputs_Type; Stream : out Outputs_Type_ACN_Stream; result : OUT adaasn1rtl.ASN1_RESULT);

procedure Outputs_Type_ACN_Encode_aux(val : Outputs_Type; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
with
    Pre => bs.Current_Bit_Pos < Natural'Last - Outputs_Type_REQUIRED_BITS_FOR_ACN_ENCODING
      and then bs.Size_In_Bytes < Positive'Last / 8
      and then bs.Current_Bit_Pos + Outputs_Type_REQUIRED_BITS_FOR_ACN_ENCODING <= bs.Size_In_Bytes * 8,
       Post =>
         (result.Success and bs.Current_Bit_Pos >= bs'Old.Current_Bit_Pos and bs.Current_Bit_Pos <= bs'Old.Current_Bit_Pos + Outputs_Type_REQUIRED_BITS_FOR_ACN_ENCODING)
       or
         not result.Success
;



ERR_ACN_DECODE_OUTPUTS_TYPE:constant Integer := 90;
ERR_ACN_DECODE_OUTPUTS_TYPE_HEATER_ENABLE:constant Integer := 55;
ERR_ACN_DECODE_OUTPUTS_TYPE_STEPPER_OUTPUT_ENABLE:constant Integer := 65;
ERR_ACN_DECODE_OUTPUTS_TYPE_STEPPER_OUTPUT_ENABLE_ELM:constant Integer := 60;
ERR_ACN_DECODE_OUTPUTS_TYPE_STEPPER_ENABLE:constant Integer := 75;
ERR_ACN_DECODE_OUTPUTS_TYPE_STEPPER_ENABLE_ELM:constant Integer := 70;
ERR_ACN_DECODE_OUTPUTS_TYPE_FAN_PWM:constant Integer := 85;
ERR_ACN_DECODE_OUTPUTS_TYPE_FAN_PWM_ELM:constant Integer := 80;
procedure Outputs_Type_ACN_Decode(val: out Outputs_Type; Stream : in out Outputs_Type_ACN_Stream; result : OUT adaasn1rtl.ASN1_RESULT);

procedure Outputs_Type_ACN_Decode_aux(val:out Outputs_Type; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
with
    Pre => bs.Current_Bit_Pos < Natural'Last - Outputs_Type_REQUIRED_BITS_FOR_ACN_ENCODING
      and then bs.Size_In_Bytes < Positive'Last / 8
      and then bs.Current_Bit_Pos + Outputs_Type_REQUIRED_BITS_FOR_ACN_ENCODING <= bs.Size_In_Bytes * 8,
       Post =>
         (result.Success and bs.Current_Bit_Pos >= bs'Old.Current_Bit_Pos and bs.Current_Bit_Pos <= bs'Old.Current_Bit_Pos + Outputs_Type_REQUIRED_BITS_FOR_ACN_ENCODING)
       or
         not result.Success
;
-- Packet_Data_Type --------------------------------------------

subtype Packet_Data_Type_index_range is Integer range 0..2;

type Packet_Data_Type_selection is (setup_PRESENT, inputs_PRESENT, outputs_PRESENT);
for Packet_Data_Type_selection use
    (setup_PRESENT => 1, inputs_PRESENT => 2, outputs_PRESENT => 3);
for Packet_Data_Type_selection'Size use 32;

type Packet_Data_Type(kind : Packet_Data_Type_selection:= setup_PRESENT) is
record
    case kind is
    when setup_PRESENT =>
            setup: Setup_Type;
    when inputs_PRESENT =>
            inputs: Inputs_Type;
    when outputs_PRESENT =>
            outputs: Outputs_Type;
    end case;
end record;

for Packet_Data_Type use
record
    kind at 0 range 0..31;
end record;

function Packet_Data_Type_Equal(val1, val2 : Packet_Data_Type) return Boolean;

ERR_PACKET_DATA_TYPE:constant Integer := 201; --
ERR_PACKET_DATA_TYPE_SETUP_2:constant Integer := 106; --
ERR_PACKET_DATA_TYPE_INPUTS_2:constant Integer := 151; --
ERR_PACKET_DATA_TYPE_OUTPUTS_2:constant Integer := 196; --
function Packet_Data_Type_IsConstraintValid(val : Packet_Data_Type) return adaasn1rtl.ASN1_RESULT;

function Packet_Data_Type_Init  return Packet_Data_Type is
((kind => setup_PRESENT, setup => Setup_Type_Init));

ERR_ACN_ENCODE_PACKET_DATA_TYPE:constant Integer := 204;
ERR_ACN_ENCODE_PACKET_DATA_TYPE_SETUP_2:constant Integer := 109;
ERR_ACN_ENCODE_PACKET_DATA_TYPE_INPUTS_2:constant Integer := 154;
ERR_ACN_ENCODE_PACKET_DATA_TYPE_OUTPUTS_2:constant Integer := 199;
Packet_Data_Type_REQUIRED_BYTES_FOR_ACN_ENCODING:constant Integer := 19;
Packet_Data_Type_REQUIRED_BITS_FOR_ACN_ENCODING:constant Integer := 152;

subtype Packet_Data_Type_ACN_Stream is adaasn1rtl.encoding.Bitstream(Packet_Data_Type_REQUIRED_BYTES_FOR_ACN_ENCODING);

procedure Packet_Data_Type_ACN_Encode(val : Packet_Data_Type; Stream : out Packet_Data_Type_ACN_Stream; result : OUT adaasn1rtl.ASN1_RESULT);

procedure Packet_Data_Type_ACN_Encode_aux(val : Packet_Data_Type; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
with
    Pre => bs.Current_Bit_Pos < Natural'Last - Packet_Data_Type_REQUIRED_BITS_FOR_ACN_ENCODING
      and then bs.Size_In_Bytes < Positive'Last / 8
      and then bs.Current_Bit_Pos + Packet_Data_Type_REQUIRED_BITS_FOR_ACN_ENCODING <= bs.Size_In_Bytes * 8,
       Post =>
         (result.Success and bs.Current_Bit_Pos >= bs'Old.Current_Bit_Pos and bs.Current_Bit_Pos <= bs'Old.Current_Bit_Pos + Packet_Data_Type_REQUIRED_BITS_FOR_ACN_ENCODING)
       or
         not result.Success
;



ERR_ACN_DECODE_PACKET_DATA_TYPE:constant Integer := 205;
ERR_ACN_DECODE_PACKET_DATA_TYPE_SETUP_2:constant Integer := 110;
ERR_ACN_DECODE_PACKET_DATA_TYPE_INPUTS_2:constant Integer := 155;
ERR_ACN_DECODE_PACKET_DATA_TYPE_OUTPUTS_2:constant Integer := 200;
procedure Packet_Data_Type_ACN_Decode(val: out Packet_Data_Type; Stream : in out Packet_Data_Type_ACN_Stream; result : OUT adaasn1rtl.ASN1_RESULT);

procedure Packet_Data_Type_ACN_Decode_aux(val:out Packet_Data_Type; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
with
    Pre => bs.Current_Bit_Pos < Natural'Last - Packet_Data_Type_REQUIRED_BITS_FOR_ACN_ENCODING
      and then bs.Size_In_Bytes < Positive'Last / 8
      and then bs.Current_Bit_Pos + Packet_Data_Type_REQUIRED_BITS_FOR_ACN_ENCODING <= bs.Size_In_Bytes * 8,
       Post =>
         (result.Success and bs.Current_Bit_Pos >= bs'Old.Current_Bit_Pos and bs.Current_Bit_Pos <= bs'Old.Current_Bit_Pos + Packet_Data_Type_REQUIRED_BITS_FOR_ACN_ENCODING)
       or
         not result.Success
;
-- Packet_Type --------------------------------------------

type Packet_Type_extension_function_positions is record
    Packet_Type_body_length_in_bytes : adaasn1rtl.encoding.BitstreamPtr;
    Packet_Type_packet_crc32 : adaasn1rtl.encoding.BitstreamPtr;
end record;
type Packet_Type is record
    packet_data : Packet_Data_Type;
end record;


function Packet_Type_Equal(val1, val2 : Packet_Type) return Boolean;

ERR_PACKET_TYPE:constant Integer := 325; --
ERR_PACKET_TYPE_PACKET_DATA_2:constant Integer := 320; --
function Packet_Type_IsConstraintValid(val : Packet_Type) return adaasn1rtl.ASN1_RESULT;

function Packet_Type_Init  return Packet_Type is
((packet_data => Packet_Data_Type_Init));

ERR_ACN_ENCODE_PACKET_TYPE:constant Integer := 328;
ERR_ACN_ENCODE_PACKET_TYPE_BODY_LENGTH_IN_BYTES:constant Integer := 206;
ERR_ACN_ENCODE_PACKET_TYPE_PACKET_DATA_KIND_UNINITIALIZED:constant Integer := 329;
ERR_ACN_ENCODE_PACKET_TYPE_PACKET_DATA_KIND:constant Integer := 208;
ERR_ACN_ENCODE_PACKET_TYPE_PACKET_DATA:constant Integer := 318;
ERR_ACN_ENCODE_PACKET_TYPE_PACKET_DATA_SETUP_2:constant Integer := 223;
ERR_ACN_ENCODE_PACKET_TYPE_PACKET_DATA_INPUTS_2:constant Integer := 268;
ERR_ACN_ENCODE_PACKET_TYPE_PACKET_DATA_OUTPUTS_2:constant Integer := 313;
ERR_ACN_ENCODE_PACKET_TYPE_PACKET_CRC32:constant Integer := 323;
Packet_Type_REQUIRED_BYTES_FOR_ACN_ENCODING:constant Integer := 27;
Packet_Type_REQUIRED_BITS_FOR_ACN_ENCODING:constant Integer := 213;

subtype Packet_Type_ACN_Stream is adaasn1rtl.encoding.Bitstream(Packet_Type_REQUIRED_BYTES_FOR_ACN_ENCODING);

procedure Packet_Type_ACN_Encode(val : Packet_Type; Stream : out Packet_Type_ACN_Stream; result : OUT adaasn1rtl.ASN1_RESULT);

procedure Packet_Type_ACN_Encode_aux(val : Packet_Type; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
with
    Pre => bs.Current_Bit_Pos < Natural'Last - Packet_Type_REQUIRED_BITS_FOR_ACN_ENCODING
      and then bs.Size_In_Bytes < Positive'Last / 8
      and then bs.Current_Bit_Pos + Packet_Type_REQUIRED_BITS_FOR_ACN_ENCODING <= bs.Size_In_Bytes * 8,
       Post =>
         (result.Success and bs.Current_Bit_Pos >= bs'Old.Current_Bit_Pos and bs.Current_Bit_Pos <= bs'Old.Current_Bit_Pos + Packet_Type_REQUIRED_BITS_FOR_ACN_ENCODING)
       or
         not result.Success
;



ERR_ACN_DECODE_PACKET_TYPE:constant Integer := 330;
ERR_ACN_DECODE_PACKET_TYPE_BODY_LENGTH_IN_BYTES:constant Integer := 207;
ERR_ACN_DECODE_PACKET_TYPE_PACKET_DATA_KIND:constant Integer := 209;
ERR_ACN_DECODE_PACKET_TYPE_PACKET_DATA:constant Integer := 319;
ERR_ACN_DECODE_PACKET_TYPE_PACKET_DATA_SETUP_2:constant Integer := 224;
ERR_ACN_DECODE_PACKET_TYPE_PACKET_DATA_INPUTS_2:constant Integer := 269;
ERR_ACN_DECODE_PACKET_TYPE_PACKET_DATA_OUTPUTS_2:constant Integer := 314;
ERR_ACN_DECODE_PACKET_TYPE_PACKET_CRC32:constant Integer := 324;
procedure Packet_Type_ACN_Decode(val: out Packet_Type; Stream : in out Packet_Type_ACN_Stream; result : OUT adaasn1rtl.ASN1_RESULT);

procedure Packet_Type_ACN_Decode_aux(val:out Packet_Type; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
with
    Pre => bs.Current_Bit_Pos < Natural'Last - Packet_Type_REQUIRED_BITS_FOR_ACN_ENCODING
      and then bs.Size_In_Bytes < Positive'Last / 8
      and then bs.Current_Bit_Pos + Packet_Type_REQUIRED_BITS_FOR_ACN_ENCODING <= bs.Size_In_Bytes * 8,
       Post =>
         (result.Success and bs.Current_Bit_Pos >= bs'Old.Current_Bit_Pos and bs.Current_Bit_Pos <= bs'Old.Current_Bit_Pos + Packet_Type_REQUIRED_BITS_FOR_ACN_ENCODING)
       or
         not result.Success
;
subtype Packet_Data_Kind_index_range is Integer range 0..2;
type Packet_Data_Kind is (setup, inputs, outputs) with Size => adaasn1rtl.Enumerated_Size;
for Packet_Data_Kind use
    (setup => 0, inputs => 1, outputs => 2);

function Packet_Data_Kind_Equal(val1, val2 : Packet_Data_Kind) return Boolean;

ERR_PACKET_DATA_KIND:constant Integer := 91; -- setup | inputs | outputs
function Packet_Data_Kind_IsConstraintValid(val : Packet_Data_Kind) return adaasn1rtl.ASN1_RESULT;

function Packet_Data_Kind_Init  return Packet_Data_Kind is
(setup);

ERR_ACN_ENCODE_PACKET_DATA_KIND:constant Integer := 94;
Packet_Data_Kind_REQUIRED_BYTES_FOR_ACN_ENCODING:constant Integer := 1;
Packet_Data_Kind_REQUIRED_BITS_FOR_ACN_ENCODING:constant Integer := 2;

subtype Packet_Data_Kind_ACN_Stream is adaasn1rtl.encoding.Bitstream(Packet_Data_Kind_REQUIRED_BYTES_FOR_ACN_ENCODING);

procedure Packet_Data_Kind_ACN_Encode(val : Packet_Data_Kind; Stream : out Packet_Data_Kind_ACN_Stream; result : OUT adaasn1rtl.ASN1_RESULT);

procedure Packet_Data_Kind_ACN_Encode_aux(val : Packet_Data_Kind; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
with
    Pre => bs.Current_Bit_Pos < Natural'Last - Packet_Data_Kind_REQUIRED_BITS_FOR_ACN_ENCODING
      and then bs.Size_In_Bytes < Positive'Last / 8
      and then bs.Current_Bit_Pos + Packet_Data_Kind_REQUIRED_BITS_FOR_ACN_ENCODING <= bs.Size_In_Bytes * 8,
       Post =>
         (result.Success and bs.Current_Bit_Pos >= bs'Old.Current_Bit_Pos and bs.Current_Bit_Pos <= bs'Old.Current_Bit_Pos + Packet_Data_Kind_REQUIRED_BITS_FOR_ACN_ENCODING)
       or
         not result.Success
;



ERR_ACN_DECODE_PACKET_DATA_KIND:constant Integer := 95;
procedure Packet_Data_Kind_ACN_Decode(val: out Packet_Data_Kind; Stream : in out Packet_Data_Kind_ACN_Stream; result : OUT adaasn1rtl.ASN1_RESULT);

procedure Packet_Data_Kind_ACN_Decode_aux(val:out Packet_Data_Kind; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
with
    Pre => bs.Current_Bit_Pos < Natural'Last - Packet_Data_Kind_REQUIRED_BITS_FOR_ACN_ENCODING
      and then bs.Size_In_Bytes < Positive'Last / 8
      and then bs.Current_Bit_Pos + Packet_Data_Kind_REQUIRED_BITS_FOR_ACN_ENCODING <= bs.Size_In_Bytes * 8,
       Post =>
         (result.Success and bs.Current_Bit_Pos >= bs'Old.Current_Bit_Pos and bs.Current_Bit_Pos <= bs'Old.Current_Bit_Pos + Packet_Data_Kind_REQUIRED_BITS_FOR_ACN_ENCODING)
       or
         not result.Success
;
pragma Warnings (Off, "there are no others");
pragma Warnings (On, "there are no others");
private
   --# hide MCU_COMMS;


end MCU_COMMS;
