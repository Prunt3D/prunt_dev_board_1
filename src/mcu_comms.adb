pragma Style_Checks (Off);
--  Code automatically generated by asn1scc tool

pragma Warnings (Off, """String"" is already use-visible inside package ""Standard""");

pragma Warnings (Off, "redundant with clause in body");

pragma Warnings (Off, "no entities of ""adaasn1rtl.encoding.uper"" are referenced");
pragma Warnings (Off, "use clause for package ""adaasn1rtl.encoding.uper"" has no effect");
pragma Warnings (Off, "unit ""adaasn1rtl.encoding.uper"" is not referenced");
with adaasn1rtl.encoding.uper;
pragma Warnings (On, "no entities of ""adaasn1rtl.encoding.uper"" are referenced");
pragma Warnings (On, "use clause for package ""adaasn1rtl.encoding.uper"" has no effect");
pragma Warnings (On, "unit ""adaasn1rtl.encoding.uper"" is not referenced");


pragma Warnings (Off, "no entities of ""adaasn1rtl.encoding.acn"" are referenced");
pragma Warnings (Off, "use clause for package ""adaasn1rtl.encoding.acn"" has no effect");
pragma Warnings (Off, "unit ""adaasn1rtl.encoding.acn"" is not referenced");
with adaasn1rtl.encoding.acn;
pragma Warnings (On, "no entities of ""adaasn1rtl.encoding.acn"" are referenced");
pragma Warnings (On, "use clause for package ""adaasn1rtl.encoding.acn"" has no effect");
pragma Warnings (On, "unit ""adaasn1rtl.encoding.acn"" is not referenced");


pragma Warnings (Off, "no entities of ""postencoding"" are referenced");
pragma Warnings (Off, "use clause for package ""postencoding"" has no effect");
pragma Warnings (Off, "unit ""postencoding"" is not referenced");
with postencoding;
pragma Warnings (On, "no entities of ""postencoding"" are referenced");
pragma Warnings (On, "use clause for package ""postencoding"" has no effect");
pragma Warnings (On, "unit ""postencoding"" is not referenced");

pragma Warnings (On, "redundant with clause in body");

package body MCU_COMMS with SPARK_Mode is


pragma Warnings (Off, "condition can only be False if invalid values present");
pragma Warnings (Off, "condition can only be True if invalid values present");


function Setup_Type_version_Equal (val1, val2 :  Setup_Type_version) return Boolean
is

begin
	return val1 = val2;

end Setup_Type_version_Equal;

function Setup_Type_Equal (val1, val2 :  Setup_Type) return Boolean
is
    pragma Warnings (Off, "initialization of ""ret"" has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ""ret"" has no effect");

begin
    ret := Setup_Type_version_Equal(val1.version, val2.version);

	return ret;

end Setup_Type_Equal;

function Setup_Type_version_IsConstraintValid(val : Setup_Type_version) return adaasn1rtl.ASN1_RESULT
is
    pragma Unreferenced (val);
    pragma Warnings (Off, "initialization of ""ret"" has no effect");
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ""ret"" has no effect");
begin
    ret := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    return ret;
end Setup_Type_version_IsConstraintValid;

function Setup_Type_IsConstraintValid(val : Setup_Type) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ""ret"" has no effect");
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ""ret"" has no effect");
begin
    ret := Setup_Type_version_IsConstraintValid(val.version);
    return ret;
end Setup_Type_IsConstraintValid;




procedure Setup_Type_ACN_Encode_aux(val : Setup_Type; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
is

begin
    result := Setup_Type_IsConstraintValid(val);
    if result.success and  result.ErrorCode = 0 then
        -- Encode version
        adaasn1rtl.encoding.uper.UPER_Enc_ConstraintPosWholeNumber(bs, adaasn1rtl.Asn1UInt(val.version), 0, 16);
    end if;
end Setup_Type_ACN_Encode_aux;
procedure Setup_Type_ACN_Encode(val : Setup_Type; Stream : out Setup_Type_ACN_Stream; result : out adaasn1rtl.ASN1_RESULT)
is
begin
    Stream := Setup_Type_ACN_Stream'(Size_In_Bytes => Setup_Type_REQUIRED_BYTES_FOR_ACN_ENCODING, Current_Bit_Pos  => 0, pushDataPrm  => 0, fetchDataPrm => 0, Buffer => (others => 0));
    Setup_Type_ACN_Encode_aux(val, Stream, result);
end Setup_Type_ACN_Encode;

procedure Setup_Type_ACN_Decode_aux(val:out Setup_Type; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
is

begin
    -- Decode version
    result.ErrorCode := ERR_ACN_DECODE_SETUP_TYPE_VERSION;
    adaasn1rtl.encoding.uper.UPER_Dec_ConstraintPosWholeNumberUInt16(bs, val.version, 0, 65535, 16, result.Success);
end Setup_Type_ACN_Decode_aux;
PROCEDURE Setup_Type_ACN_Decode(val: out Setup_Type; Stream : in out Setup_Type_ACN_Stream; result : OUT adaasn1rtl.ASN1_RESULT)
is
begin
    Stream.Current_Bit_Pos :=0;
    Setup_Type_ACN_Decode_aux(val, Stream, result);
    if result.success then
        result := Setup_Type_IsConstraintValid(val);
    end if;

end Setup_Type_ACN_Decode;



function Inputs_Type_stepper_fault_Equal (val1, val2 :  Inputs_Type_stepper_fault) return Boolean
is
    pragma Warnings (Off, "initialization of ""ret"" has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ""ret"" has no effect");
    i1:Integer;

begin
    i1 := val1.Data'First;
    while ret and i1 <= 6 loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First);
        ret := (val1.Data(i1) = val2.Data(i1));
        i1 := i1+1;
    end loop;
	return ret;

end Inputs_Type_stepper_fault_Equal;

function Inputs_Type_adc_sequential_id_Equal (val1, val2 :  Inputs_Type_adc_sequential_id) return Boolean
is

begin
	return val1 = val2;

end Inputs_Type_adc_sequential_id_Equal;

function Inputs_Type_adc_temp_value_elem_Equal (val1, val2 :  Inputs_Type_adc_temp_value_elem) return Boolean
is

begin
	return val1 = val2;

end Inputs_Type_adc_temp_value_elem_Equal;

function Inputs_Type_adc_temp_value_Equal (val1, val2 :  Inputs_Type_adc_temp_value) return Boolean
is
    pragma Warnings (Off, "initialization of ""ret"" has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ""ret"" has no effect");
    i1:Integer;

begin
    i1 := val1.Data'First;
    while ret and i1 <= 4 loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First);
        ret := Inputs_Type_adc_temp_value_elem_Equal(val1.Data(i1), val2.Data(i1));
        i1 := i1+1;
    end loop;
	return ret;

end Inputs_Type_adc_temp_value_Equal;

function Inputs_Type_fan_tach_count_elem_Equal (val1, val2 :  Inputs_Type_fan_tach_count_elem) return Boolean
is

begin
	return val1 = val2;

end Inputs_Type_fan_tach_count_elem_Equal;

function Inputs_Type_fan_tach_count_Equal (val1, val2 :  Inputs_Type_fan_tach_count) return Boolean
is
    pragma Warnings (Off, "initialization of ""ret"" has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ""ret"" has no effect");
    i1:Integer;

begin
    i1 := val1.Data'First;
    while ret and i1 <= 4 loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First);
        ret := Inputs_Type_fan_tach_count_elem_Equal(val1.Data(i1), val2.Data(i1));
        i1 := i1+1;
    end loop;
	return ret;

end Inputs_Type_fan_tach_count_Equal;

function Inputs_Type_Equal (val1, val2 :  Inputs_Type) return Boolean
is
    pragma Warnings (Off, "initialization of ""ret"" has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ""ret"" has no effect");

begin
    ret := Inputs_Type_stepper_fault_Equal(val1.stepper_fault, val2.stepper_fault);

    if ret then
        ret := Inputs_Type_adc_sequential_id_Equal(val1.adc_sequential_id, val2.adc_sequential_id);

        if ret then
            ret := Inputs_Type_adc_temp_value_Equal(val1.adc_temp_value, val2.adc_temp_value);

            if ret then
                ret := Inputs_Type_fan_tach_count_Equal(val1.fan_tach_count, val2.fan_tach_count);

            end if;
        end if;
    end if;
	return ret;

end Inputs_Type_Equal;

function Inputs_Type_stepper_fault_IsConstraintValid(val : Inputs_Type_stepper_fault) return adaasn1rtl.ASN1_RESULT
is
    pragma Unreferenced (val);
    pragma Warnings (Off, "initialization of ""ret"" has no effect");
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ""ret"" has no effect");
begin
    ret := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    return ret;
end Inputs_Type_stepper_fault_IsConstraintValid;

function Inputs_Type_adc_sequential_id_IsConstraintValid(val : Inputs_Type_adc_sequential_id) return adaasn1rtl.ASN1_RESULT
is
    pragma Unreferenced (val);
    pragma Warnings (Off, "initialization of ""ret"" has no effect");
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ""ret"" has no effect");
begin
    ret := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    return ret;
end Inputs_Type_adc_sequential_id_IsConstraintValid;

function Inputs_Type_adc_temp_value_elem_IsConstraintValid(val : Inputs_Type_adc_temp_value_elem) return adaasn1rtl.ASN1_RESULT
is
    pragma Unreferenced (val);
    pragma Warnings (Off, "initialization of ""ret"" has no effect");
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ""ret"" has no effect");
begin
    ret := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    return ret;
end Inputs_Type_adc_temp_value_elem_IsConstraintValid;

function Inputs_Type_adc_temp_value_IsConstraintValid(val : Inputs_Type_adc_temp_value) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ""ret"" has no effect");
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ""ret"" has no effect");
    i1:Integer;
begin
    i1 := val.Data'First;
    while ret.Success and i1 <= 4 loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= 4);
        ret := Inputs_Type_adc_temp_value_elem_IsConstraintValid(val.Data(i1));
        i1 := i1+1;
    end loop;
    return ret;
end Inputs_Type_adc_temp_value_IsConstraintValid;

function Inputs_Type_fan_tach_count_elem_IsConstraintValid(val : Inputs_Type_fan_tach_count_elem) return adaasn1rtl.ASN1_RESULT
is
    pragma Unreferenced (val);
    pragma Warnings (Off, "initialization of ""ret"" has no effect");
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ""ret"" has no effect");
begin
    ret := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    return ret;
end Inputs_Type_fan_tach_count_elem_IsConstraintValid;

function Inputs_Type_fan_tach_count_IsConstraintValid(val : Inputs_Type_fan_tach_count) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ""ret"" has no effect");
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ""ret"" has no effect");
    i1:Integer;
begin
    i1 := val.Data'First;
    while ret.Success and i1 <= 4 loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= 4);
        ret := Inputs_Type_fan_tach_count_elem_IsConstraintValid(val.Data(i1));
        i1 := i1+1;
    end loop;
    return ret;
end Inputs_Type_fan_tach_count_IsConstraintValid;

function Inputs_Type_IsConstraintValid(val : Inputs_Type) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ""ret"" has no effect");
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ""ret"" has no effect");
begin
    ret := Inputs_Type_stepper_fault_IsConstraintValid(val.stepper_fault);
    if ret.Success then
        ret := Inputs_Type_adc_sequential_id_IsConstraintValid(val.adc_sequential_id);
        if ret.Success then
            ret := Inputs_Type_adc_temp_value_IsConstraintValid(val.adc_temp_value);
            if ret.Success then
                ret := Inputs_Type_fan_tach_count_IsConstraintValid(val.fan_tach_count);
            end if;
        end if;
    end if;
    return ret;
end Inputs_Type_IsConstraintValid;









procedure Inputs_Type_ACN_Encode_aux(val : Inputs_Type; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
is
    i1:Integer;
begin
    result := Inputs_Type_IsConstraintValid(val);
    if result.success and  result.ErrorCode = 0 then
        -- Encode stepper_fault
        i1 := 1;
        while i1<= 6 loop
            pragma Loop_Invariant (i1 >=1 and i1<=6);
            pragma Loop_Invariant (bs.Current_Bit_Pos >= bs.Current_Bit_Pos'Loop_Entry);
            pragma Loop_Invariant (bs.Current_Bit_Pos<=bs.Current_Bit_Pos'Loop_Entry + 1*(i1-1));
            adaasn1rtl.encoding.uper.UPER_Enc_Boolean(bs, val.stepper_fault.Data(i1));
            i1 := i1 + 1;
        end loop;
        if result.Success then
            -- Encode adc_sequential_id
            adaasn1rtl.encoding.uper.UPER_Enc_ConstraintPosWholeNumber(bs, adaasn1rtl.Asn1UInt(val.adc_sequential_id), 0, 16);
            if result.Success then
                -- Encode adc_temp_value
                i1 := 1;
                while i1<= 4 loop
                    pragma Loop_Invariant (i1 >=1 and i1<=4);
                    pragma Loop_Invariant (bs.Current_Bit_Pos >= bs.Current_Bit_Pos'Loop_Entry);
                    pragma Loop_Invariant (bs.Current_Bit_Pos<=bs.Current_Bit_Pos'Loop_Entry + 16*(i1-1));
                    adaasn1rtl.encoding.uper.UPER_Enc_ConstraintPosWholeNumber(bs, adaasn1rtl.Asn1UInt(val.adc_temp_value.Data(i1)), 0, 16);
                    i1 := i1 + 1;
                end loop;
                if result.Success then
                    -- Encode fan_tach_count
                    i1 := 1;
                    while i1<= 4 loop
                        pragma Loop_Invariant (i1 >=1 and i1<=4);
                        pragma Loop_Invariant (bs.Current_Bit_Pos >= bs.Current_Bit_Pos'Loop_Entry);
                        pragma Loop_Invariant (bs.Current_Bit_Pos<=bs.Current_Bit_Pos'Loop_Entry + 16*(i1-1));
                        adaasn1rtl.encoding.uper.UPER_Enc_ConstraintPosWholeNumber(bs, adaasn1rtl.Asn1UInt(val.fan_tach_count.Data(i1)), 0, 16);
                        i1 := i1 + 1;
                    end loop;
                end if;
            end if;
        end if;
    end if;
end Inputs_Type_ACN_Encode_aux;
procedure Inputs_Type_ACN_Encode(val : Inputs_Type; Stream : out Inputs_Type_ACN_Stream; result : out adaasn1rtl.ASN1_RESULT)
is
begin
    Stream := Inputs_Type_ACN_Stream'(Size_In_Bytes => Inputs_Type_REQUIRED_BYTES_FOR_ACN_ENCODING, Current_Bit_Pos  => 0, pushDataPrm  => 0, fetchDataPrm => 0, Buffer => (others => 0));
    Inputs_Type_ACN_Encode_aux(val, Stream, result);
end Inputs_Type_ACN_Encode;

procedure Inputs_Type_ACN_Decode_aux(val:out Inputs_Type; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
is
    i1:Integer;
begin
    -- Decode stepper_fault
    result := adaasn1rtl.ASN1_RESULT'(Success => True, ErrorCode => 0);
    i1 := 1;
    while i1<= 6 AND result.Success loop
        pragma Loop_Invariant (i1 >=1 and i1<=6);
        pragma Loop_Invariant (bs.Current_Bit_Pos >= bs.Current_Bit_Pos'Loop_Entry);
        pragma Loop_Invariant (bs.Current_Bit_Pos <= bs.Current_Bit_Pos'Loop_Entry + 1*(i1-1));
        result.ErrorCode := ERR_ACN_DECODE_INPUTS_TYPE_STEPPER_FAULT_ELM;
        adaasn1rtl.encoding.uper.UPER_Dec_boolean(bs, val.stepper_fault.Data(i1), result.Success);
        i1 := i1 + 1;
    end loop;
    if result.Success then
        -- Decode adc_sequential_id
        result.ErrorCode := ERR_ACN_DECODE_INPUTS_TYPE_ADC_SEQUENTIAL_ID;
        adaasn1rtl.encoding.uper.UPER_Dec_ConstraintPosWholeNumberUInt16(bs, val.adc_sequential_id, 0, 65535, 16, result.Success);
        if result.Success then
            -- Decode adc_temp_value
            result := adaasn1rtl.ASN1_RESULT'(Success => True, ErrorCode => 0);
            i1 := 1;
            while i1<= 4 AND result.Success loop
                pragma Loop_Invariant (i1 >=1 and i1<=4);
                pragma Loop_Invariant (bs.Current_Bit_Pos >= bs.Current_Bit_Pos'Loop_Entry);
                pragma Loop_Invariant (bs.Current_Bit_Pos <= bs.Current_Bit_Pos'Loop_Entry + 16*(i1-1));
                result.ErrorCode := ERR_ACN_DECODE_INPUTS_TYPE_ADC_TEMP_VALUE_ELM;
                adaasn1rtl.encoding.uper.UPER_Dec_ConstraintPosWholeNumberUInt16(bs, val.adc_temp_value.Data(i1), 0, 65535, 16, result.Success);
                i1 := i1 + 1;
            end loop;
            if result.Success then
                -- Decode fan_tach_count
                result := adaasn1rtl.ASN1_RESULT'(Success => True, ErrorCode => 0);
                i1 := 1;
                while i1<= 4 AND result.Success loop
                    pragma Loop_Invariant (i1 >=1 and i1<=4);
                    pragma Loop_Invariant (bs.Current_Bit_Pos >= bs.Current_Bit_Pos'Loop_Entry);
                    pragma Loop_Invariant (bs.Current_Bit_Pos <= bs.Current_Bit_Pos'Loop_Entry + 16*(i1-1));
                    result.ErrorCode := ERR_ACN_DECODE_INPUTS_TYPE_FAN_TACH_COUNT_ELM;
                    adaasn1rtl.encoding.uper.UPER_Dec_ConstraintPosWholeNumberUInt16(bs, val.fan_tach_count.Data(i1), 0, 65535, 16, result.Success);
                    i1 := i1 + 1;
                end loop;
            end if;
        end if;
    end if;
end Inputs_Type_ACN_Decode_aux;
PROCEDURE Inputs_Type_ACN_Decode(val: out Inputs_Type; Stream : in out Inputs_Type_ACN_Stream; result : OUT adaasn1rtl.ASN1_RESULT)
is
begin
    Stream.Current_Bit_Pos :=0;
    Inputs_Type_ACN_Decode_aux(val, Stream, result);
    if result.success then
        result := Inputs_Type_IsConstraintValid(val);
    end if;

end Inputs_Type_ACN_Decode;



function Outputs_Type_stepper_output_enable_Equal (val1, val2 :  Outputs_Type_stepper_output_enable) return Boolean
is
    pragma Warnings (Off, "initialization of ""ret"" has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ""ret"" has no effect");
    i1:Integer;

begin
    i1 := val1.Data'First;
    while ret and i1 <= 6 loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First);
        ret := (val1.Data(i1) = val2.Data(i1));
        i1 := i1+1;
    end loop;
	return ret;

end Outputs_Type_stepper_output_enable_Equal;

function Outputs_Type_stepper_enable_Equal (val1, val2 :  Outputs_Type_stepper_enable) return Boolean
is
    pragma Warnings (Off, "initialization of ""ret"" has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ""ret"" has no effect");
    i1:Integer;

begin
    i1 := val1.Data'First;
    while ret and i1 <= 6 loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First);
        ret := (val1.Data(i1) = val2.Data(i1));
        i1 := i1+1;
    end loop;
	return ret;

end Outputs_Type_stepper_enable_Equal;

function Outputs_Type_fan_pwm_elem_Equal (val1, val2 :  Outputs_Type_fan_pwm_elem) return Boolean
is

begin
	return val1 = val2;

end Outputs_Type_fan_pwm_elem_Equal;

function Outputs_Type_fan_pwm_Equal (val1, val2 :  Outputs_Type_fan_pwm) return Boolean
is
    pragma Warnings (Off, "initialization of ""ret"" has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ""ret"" has no effect");
    i1:Integer;

begin
    i1 := val1.Data'First;
    while ret and i1 <= 4 loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First);
        ret := Outputs_Type_fan_pwm_elem_Equal(val1.Data(i1), val2.Data(i1));
        i1 := i1+1;
    end loop;
	return ret;

end Outputs_Type_fan_pwm_Equal;

function Outputs_Type_Equal (val1, val2 :  Outputs_Type) return Boolean
is
    pragma Warnings (Off, "initialization of ""ret"" has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ""ret"" has no effect");

begin
    ret := (val1.heater_enable = val2.heater_enable);

    if ret then
        ret := Outputs_Type_stepper_output_enable_Equal(val1.stepper_output_enable, val2.stepper_output_enable);

        if ret then
            ret := Outputs_Type_stepper_enable_Equal(val1.stepper_enable, val2.stepper_enable);

            if ret then
                ret := Outputs_Type_fan_pwm_Equal(val1.fan_pwm, val2.fan_pwm);

            end if;
        end if;
    end if;
	return ret;

end Outputs_Type_Equal;

function Outputs_Type_stepper_output_enable_IsConstraintValid(val : Outputs_Type_stepper_output_enable) return adaasn1rtl.ASN1_RESULT
is
    pragma Unreferenced (val);
    pragma Warnings (Off, "initialization of ""ret"" has no effect");
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ""ret"" has no effect");
begin
    ret := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    return ret;
end Outputs_Type_stepper_output_enable_IsConstraintValid;

function Outputs_Type_stepper_enable_IsConstraintValid(val : Outputs_Type_stepper_enable) return adaasn1rtl.ASN1_RESULT
is
    pragma Unreferenced (val);
    pragma Warnings (Off, "initialization of ""ret"" has no effect");
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ""ret"" has no effect");
begin
    ret := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    return ret;
end Outputs_Type_stepper_enable_IsConstraintValid;

function Outputs_Type_fan_pwm_elem_IsConstraintValid(val : Outputs_Type_fan_pwm_elem) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ""ret"" has no effect");
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ""ret"" has no effect");
begin
    ret.Success := (val <= 639);
    ret.ErrorCode := (if ret.Success then 0 else ERR_OUTPUTS_TYPE_FAN_PWM_ELM);
    return ret;
end Outputs_Type_fan_pwm_elem_IsConstraintValid;

function Outputs_Type_fan_pwm_IsConstraintValid(val : Outputs_Type_fan_pwm) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ""ret"" has no effect");
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ""ret"" has no effect");
    i1:Integer;
begin
    i1 := val.Data'First;
    while ret.Success and i1 <= 4 loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= 4);
        ret := Outputs_Type_fan_pwm_elem_IsConstraintValid(val.Data(i1));
        i1 := i1+1;
    end loop;
    return ret;
end Outputs_Type_fan_pwm_IsConstraintValid;

function Outputs_Type_IsConstraintValid(val : Outputs_Type) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ""ret"" has no effect");
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ""ret"" has no effect");
begin
    ret := Outputs_Type_stepper_output_enable_IsConstraintValid(val.stepper_output_enable);
    if ret.Success then
        ret := Outputs_Type_stepper_enable_IsConstraintValid(val.stepper_enable);
        if ret.Success then
            ret := Outputs_Type_fan_pwm_IsConstraintValid(val.fan_pwm);
        end if;
    end if;
    return ret;
end Outputs_Type_IsConstraintValid;







procedure Outputs_Type_ACN_Encode_aux(val : Outputs_Type; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
is
    i1:Integer;
begin
    result := Outputs_Type_IsConstraintValid(val);
    if result.success and  result.ErrorCode = 0 then
        -- Encode heater_enable
        adaasn1rtl.encoding.uper.UPER_Enc_Boolean(bs, val.heater_enable);
        if result.Success then
            -- Encode stepper_output_enable
            i1 := 1;
            while i1<= 6 loop
                pragma Loop_Invariant (i1 >=1 and i1<=6);
                pragma Loop_Invariant (bs.Current_Bit_Pos >= bs.Current_Bit_Pos'Loop_Entry);
                pragma Loop_Invariant (bs.Current_Bit_Pos<=bs.Current_Bit_Pos'Loop_Entry + 1*(i1-1));
                adaasn1rtl.encoding.uper.UPER_Enc_Boolean(bs, val.stepper_output_enable.Data(i1));
                i1 := i1 + 1;
            end loop;
            if result.Success then
                -- Encode stepper_enable
                i1 := 1;
                while i1<= 6 loop
                    pragma Loop_Invariant (i1 >=1 and i1<=6);
                    pragma Loop_Invariant (bs.Current_Bit_Pos >= bs.Current_Bit_Pos'Loop_Entry);
                    pragma Loop_Invariant (bs.Current_Bit_Pos<=bs.Current_Bit_Pos'Loop_Entry + 1*(i1-1));
                    adaasn1rtl.encoding.uper.UPER_Enc_Boolean(bs, val.stepper_enable.Data(i1));
                    i1 := i1 + 1;
                end loop;
                if result.Success then
                    -- Encode fan_pwm
                    i1 := 1;
                    while i1<= 4 loop
                        pragma Loop_Invariant (i1 >=1 and i1<=4);
                        pragma Loop_Invariant (bs.Current_Bit_Pos >= bs.Current_Bit_Pos'Loop_Entry);
                        pragma Loop_Invariant (bs.Current_Bit_Pos<=bs.Current_Bit_Pos'Loop_Entry + 10*(i1-1));
                        adaasn1rtl.encoding.uper.UPER_Enc_ConstraintPosWholeNumber(bs, adaasn1rtl.Asn1UInt(val.fan_pwm.Data(i1)), 0, 10);
                        i1 := i1 + 1;
                    end loop;
                end if;
            end if;
        end if;
    end if;
end Outputs_Type_ACN_Encode_aux;
procedure Outputs_Type_ACN_Encode(val : Outputs_Type; Stream : out Outputs_Type_ACN_Stream; result : out adaasn1rtl.ASN1_RESULT)
is
begin
    Stream := Outputs_Type_ACN_Stream'(Size_In_Bytes => Outputs_Type_REQUIRED_BYTES_FOR_ACN_ENCODING, Current_Bit_Pos  => 0, pushDataPrm  => 0, fetchDataPrm => 0, Buffer => (others => 0));
    Outputs_Type_ACN_Encode_aux(val, Stream, result);
end Outputs_Type_ACN_Encode;

procedure Outputs_Type_ACN_Decode_aux(val:out Outputs_Type; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
is
    i1:Integer;
begin
    -- Decode heater_enable
    result.ErrorCode := ERR_ACN_DECODE_OUTPUTS_TYPE_HEATER_ENABLE;
    adaasn1rtl.encoding.uper.UPER_Dec_boolean(bs, val.heater_enable, result.Success);
    if result.Success then
        -- Decode stepper_output_enable
        result := adaasn1rtl.ASN1_RESULT'(Success => True, ErrorCode => 0);
        i1 := 1;
        while i1<= 6 AND result.Success loop
            pragma Loop_Invariant (i1 >=1 and i1<=6);
            pragma Loop_Invariant (bs.Current_Bit_Pos >= bs.Current_Bit_Pos'Loop_Entry);
            pragma Loop_Invariant (bs.Current_Bit_Pos <= bs.Current_Bit_Pos'Loop_Entry + 1*(i1-1));
            result.ErrorCode := ERR_ACN_DECODE_OUTPUTS_TYPE_STEPPER_OUTPUT_ENABLE_ELM;
            adaasn1rtl.encoding.uper.UPER_Dec_boolean(bs, val.stepper_output_enable.Data(i1), result.Success);
            i1 := i1 + 1;
        end loop;
        if result.Success then
            -- Decode stepper_enable
            result := adaasn1rtl.ASN1_RESULT'(Success => True, ErrorCode => 0);
            i1 := 1;
            while i1<= 6 AND result.Success loop
                pragma Loop_Invariant (i1 >=1 and i1<=6);
                pragma Loop_Invariant (bs.Current_Bit_Pos >= bs.Current_Bit_Pos'Loop_Entry);
                pragma Loop_Invariant (bs.Current_Bit_Pos <= bs.Current_Bit_Pos'Loop_Entry + 1*(i1-1));
                result.ErrorCode := ERR_ACN_DECODE_OUTPUTS_TYPE_STEPPER_ENABLE_ELM;
                adaasn1rtl.encoding.uper.UPER_Dec_boolean(bs, val.stepper_enable.Data(i1), result.Success);
                i1 := i1 + 1;
            end loop;
            if result.Success then
                -- Decode fan_pwm
                result := adaasn1rtl.ASN1_RESULT'(Success => True, ErrorCode => 0);
                i1 := 1;
                while i1<= 4 AND result.Success loop
                    pragma Loop_Invariant (i1 >=1 and i1<=4);
                    pragma Loop_Invariant (bs.Current_Bit_Pos >= bs.Current_Bit_Pos'Loop_Entry);
                    pragma Loop_Invariant (bs.Current_Bit_Pos <= bs.Current_Bit_Pos'Loop_Entry + 10*(i1-1));
                    result.ErrorCode := ERR_ACN_DECODE_OUTPUTS_TYPE_FAN_PWM_ELM;
                    adaasn1rtl.encoding.uper.UPER_Dec_ConstraintPosWholeNumberUInt16(bs, val.fan_pwm.Data(i1), 0, 639, 10, result.Success);
                    i1 := i1 + 1;
                end loop;
            end if;
        end if;
    end if;
end Outputs_Type_ACN_Decode_aux;
PROCEDURE Outputs_Type_ACN_Decode(val: out Outputs_Type; Stream : in out Outputs_Type_ACN_Stream; result : OUT adaasn1rtl.ASN1_RESULT)
is
begin
    Stream.Current_Bit_Pos :=0;
    Outputs_Type_ACN_Decode_aux(val, Stream, result);
    if result.success then
        result := Outputs_Type_IsConstraintValid(val);
    end if;

end Outputs_Type_ACN_Decode;



function Packet_Data_Type_Equal (val1, val2 :  Packet_Data_Type) return Boolean
is
    pragma Warnings (Off, "initialization of ""ret"" has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ""ret"" has no effect");

begin
    ret := val1.kind = val2.kind;
    if ret then
        case val1.kind is
            when setup_PRESENT =>
                ret := Setup_Type_Equal(val1.setup, val2.setup);
            when inputs_PRESENT =>
                ret := Inputs_Type_Equal(val1.inputs, val2.inputs);
            when outputs_PRESENT =>
                ret := Outputs_Type_Equal(val1.outputs, val2.outputs);
        end case;
    end if;
	return ret;

end Packet_Data_Type_Equal;

function Packet_Data_Type_IsConstraintValid(val : Packet_Data_Type) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ""ret"" has no effect");
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ""ret"" has no effect");
begin
    if val.kind = setup_PRESENT then
    	ret := Setup_Type_IsConstraintValid(val.setup);
    end if;
    if ret.Success then
        if val.kind = inputs_PRESENT then
        	ret := Inputs_Type_IsConstraintValid(val.inputs);
        end if;
        if ret.Success then
            if val.kind = outputs_PRESENT then
            	ret := Outputs_Type_IsConstraintValid(val.outputs);
            end if;
        end if;
    end if;
    return ret;
end Packet_Data_Type_IsConstraintValid;



procedure Packet_Data_Type_ACN_Encode_aux(val : Packet_Data_Type; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
is

begin
    result := Packet_Data_Type_IsConstraintValid(val);
    if result.success and  result.ErrorCode = 0 then
        case val.kind is
            when setup_PRESENT =>
                adaasn1rtl.encoding.Enc_ConstraintWholeNumber(bs, 0, 0, 2);
            	Setup_Type_ACN_Encode_aux(val.setup, bs, result);
            when inputs_PRESENT =>
                adaasn1rtl.encoding.Enc_ConstraintWholeNumber(bs, 1, 0, 2);
            	Inputs_Type_ACN_Encode_aux(val.inputs, bs, result);
            when outputs_PRESENT =>
                adaasn1rtl.encoding.Enc_ConstraintWholeNumber(bs, 2, 0, 2);
            	Outputs_Type_ACN_Encode_aux(val.outputs, bs, result);
        end case;
    end if;
end Packet_Data_Type_ACN_Encode_aux;
procedure Packet_Data_Type_ACN_Encode(val : Packet_Data_Type; Stream : out Packet_Data_Type_ACN_Stream; result : out adaasn1rtl.ASN1_RESULT)
is
begin
    Stream := Packet_Data_Type_ACN_Stream'(Size_In_Bytes => Packet_Data_Type_REQUIRED_BYTES_FOR_ACN_ENCODING, Current_Bit_Pos  => 0, pushDataPrm  => 0, fetchDataPrm => 0, Buffer => (others => 0));
    Packet_Data_Type_ACN_Encode_aux(val, Stream, result);
end Packet_Data_Type_ACN_Encode;

procedure Packet_Data_Type_ACN_Decode_aux(val:out Packet_Data_Type; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
is
    MCU_COMMS_Packet_Data_Type_index_tmp:adaasn1rtl.Asn1Int;
begin
    result.ErrorCode := ERR_ACN_DECODE_PACKET_DATA_TYPE;
    adaasn1rtl.encoding.Dec_ConstraintWholeNumber(bs, MCU_COMMS_Packet_Data_Type_index_tmp, 0, 2, 2, result.Success);
    if result.Success AND MCU_COMMS_Packet_Data_Type_index_tmp >= 0 AND  MCU_COMMS_Packet_Data_Type_index_tmp <= 2 then
        case Packet_Data_Type_index_range(MCU_COMMS_Packet_Data_Type_index_tmp) is
            when 0 =>
              val := Packet_Data_Type'(kind => setup_PRESENT, setup => Setup_Type_Init);
              Setup_Type_ACN_Decode_aux(val.setup, bs, result);
            when 1 =>
              val := Packet_Data_Type'(kind => inputs_PRESENT, inputs => Inputs_Type_Init);
              Inputs_Type_ACN_Decode_aux(val.inputs, bs, result);
            when 2 =>
              val := Packet_Data_Type'(kind => outputs_PRESENT, outputs => Outputs_Type_Init);
              Outputs_Type_ACN_Decode_aux(val.outputs, bs, result);
        end case;
    end if;
end Packet_Data_Type_ACN_Decode_aux;
PROCEDURE Packet_Data_Type_ACN_Decode(val: out Packet_Data_Type; Stream : in out Packet_Data_Type_ACN_Stream; result : OUT adaasn1rtl.ASN1_RESULT)
is
begin
    Stream.Current_Bit_Pos :=0;
    Packet_Data_Type_ACN_Decode_aux(val, Stream, result);
    if result.success then
        result := Packet_Data_Type_IsConstraintValid(val);
    end if;

end Packet_Data_Type_ACN_Decode;



function Packet_Type_Equal (val1, val2 :  Packet_Type) return Boolean
is
    pragma Warnings (Off, "initialization of ""ret"" has no effect");
    ret : Boolean := True;
    pragma Warnings (On, "initialization of ""ret"" has no effect");

begin
    ret := Packet_Data_Type_Equal(val1.packet_data, val2.packet_data);

	return ret;

end Packet_Type_Equal;

function Packet_Type_IsConstraintValid(val : Packet_Type) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ""ret"" has no effect");
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ""ret"" has no effect");
begin
    ret := Packet_Data_Type_IsConstraintValid(val.packet_data);
    return ret;
end Packet_Type_IsConstraintValid;



procedure Packet_Type_ACN_Encode_aux(val : Packet_Type; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
is
    bitStreamPositions_1:Packet_Type_extension_function_positions;
    bitStreamPositions_start1:adaasn1rtl.encoding.BitStreamPtr;
    Packet_Type_packet_data_kind:Packet_Data_Kind;
    Packet_Type_packet_data_kind_is_initialized:Boolean:=False;
    intVal_Packet_Type_packet_data_kind : Interfaces.Unsigned_8;
begin
    result := Packet_Type_IsConstraintValid(val);
    if result.success and  result.ErrorCode = 0 then
        bitStreamPositions_start1.Size_In_Bytes := bs.Size_In_Bytes; --save the size of the bit stream
        bitStreamPositions_start1.Current_Bit_Pos := bs.Current_Bit_Pos; --save position of the bit stream
        if result.Success then
            -- Encode Packet_Type_body_length_in_bytes
            bitStreamPositions_1.Packet_Type_body_length_in_bytes.Size_In_Bytes := bs.Size_In_Bytes; --save the size of the bit stream
            bitStreamPositions_1.Packet_Type_body_length_in_bytes.Current_Bit_Pos := bs.Current_Bit_Pos; --save position of the bit stream
            adaasn1rtl.encoding.acn.Acn_Enc_NullType_pattern2(bs, BitArray'(1=>0,2=>0,3=>0,4=>0,5=>0,6=>0,7=>0,8=>0,9=>0,10=>0,11=>0,12=>0,13=>0,14=>0,15=>0,16=>0));
            if result.Success then
                case val.packet_data.kind is
                    when setup_PRESENT =>
                        Packet_Type_packet_data_kind_is_initialized := True;
                    	Packet_Type_packet_data_kind := setup;
                    when inputs_PRESENT =>
                        Packet_Type_packet_data_kind_is_initialized := True;
                    	Packet_Type_packet_data_kind := inputs;
                    when outputs_PRESENT =>
                        Packet_Type_packet_data_kind_is_initialized := True;
                    	Packet_Type_packet_data_kind := outputs;
                end case;
                if result.Success then
                    --Encode Packet_Type_packet_data_kind
                    if Packet_Type_packet_data_kind_is_initialized then
                        result := adaasn1rtl.ASN1_RESULT'(Success => True, ErrorCode => 0);
                        case Packet_Type_packet_data_kind is
                            when setup    => intVal_Packet_Type_packet_data_kind := 0;
                            when inputs    => intVal_Packet_Type_packet_data_kind := 1;
                            when outputs    => intVal_Packet_Type_packet_data_kind := 2;
                        end case;
                        adaasn1rtl.encoding.acn.Acn_Enc_Int_PositiveInteger_ConstSize_8(bs, adaasn1rtl.Asn1UInt(intVal_Packet_Type_packet_data_kind));
                    else
                        result := adaasn1rtl.ASN1_RESULT'(Success => False, ErrorCode => ERR_ACN_ENCODE_PACKET_TYPE_PACKET_DATA_KIND_UNINITIALIZED); --COVERAGE_IGNORE
                    end if;
                    if result.Success then
                        -- Encode packet_data
                        case val.packet_data.kind is
                            when setup_PRESENT =>
                            	Setup_Type_ACN_Encode_aux(val.packet_data.setup, bs, result);
                            when inputs_PRESENT =>
                            	Inputs_Type_ACN_Encode_aux(val.packet_data.inputs, bs, result);
                            when outputs_PRESENT =>
                            	Outputs_Type_ACN_Encode_aux(val.packet_data.outputs, bs, result);
                        end case;
                        if result.Success then
                            -- Encode Packet_Type_packet_crc32
                            --align to next NextByte
                            if (bs.Current_Bit_Pos mod 8) /= 0 then
                                bs.Current_Bit_Pos := bs.Current_Bit_Pos + (8 - (bs.Current_Bit_Pos mod 8));
                            end if;
                            bitStreamPositions_1.Packet_Type_packet_crc32.Size_In_Bytes := bs.Size_In_Bytes; --save the size of the bit stream
                            bitStreamPositions_1.Packet_Type_packet_crc32.Current_Bit_Pos := bs.Current_Bit_Pos; --save position of the bit stream
                            adaasn1rtl.encoding.acn.Acn_Enc_NullType_pattern2(bs, BitArray'(1=>0,2=>0,3=>0,4=>0,5=>0,6=>0,7=>0,8=>0,9=>0,10=>0,11=>0,12=>0,13=>0,14=>0,15=>0,16=>0,17=>0,18=>0,19=>0,20=>0,21=>0,22=>0,23=>0,24=>0,25=>0,26=>0,27=>0,28=>0,29=>0,30=>0,31=>0,32=>0));
                            if result.Success then
                                postencoding.my_encoding_patcher(val, bitStreamPositions_start1, bitStreamPositions_1, bs);
                            end if;
                        end if;
                    end if;
                end if;
            end if;
        end if;
    end if;
end Packet_Type_ACN_Encode_aux;
procedure Packet_Type_ACN_Encode(val : Packet_Type; Stream : out Packet_Type_ACN_Stream; result : out adaasn1rtl.ASN1_RESULT)
is
begin
    Stream := Packet_Type_ACN_Stream'(Size_In_Bytes => Packet_Type_REQUIRED_BYTES_FOR_ACN_ENCODING, Current_Bit_Pos  => 0, pushDataPrm  => 0, fetchDataPrm => 0, Buffer => (others => 0));
    Packet_Type_ACN_Encode_aux(val, Stream, result);
end Packet_Type_ACN_Encode;

procedure Packet_Type_ACN_Decode_aux(val:out Packet_Type; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
is
    bitStreamPositions_1:Packet_Type_extension_function_positions;
    bitStreamPositions_start1:adaasn1rtl.encoding.BitStreamPtr;
    Packet_Type_packet_data_kind:Packet_Data_Kind;
    intVal_Packet_Type_packet_data_kind : Interfaces.Unsigned_8;
begin
    result.Success := True;
    bitStreamPositions_start1.Size_In_Bytes := bs.Size_In_Bytes; --save the size of the bit stream
    bitStreamPositions_start1.Current_Bit_Pos := bs.Current_Bit_Pos; --save position of the bit stream
    if result.Success then
        -- Decode Packet_Type_body_length_in_bytes
        bitStreamPositions_1.Packet_Type_body_length_in_bytes.Size_In_Bytes := bs.Size_In_Bytes; --save the size of the bit stream
        bitStreamPositions_1.Packet_Type_body_length_in_bytes.Current_Bit_Pos := bs.Current_Bit_Pos; --save position of the bit stream
        result.ErrorCode := ERR_ACN_DECODE_PACKET_TYPE_BODY_LENGTH_IN_BYTES;
        result.Success := True;
        bs.Current_Bit_Pos := bs.Current_Bit_Pos + 16;

        if result.Success then
            -- Decode Packet_Type_packet_data_kind
            adaasn1rtl.encoding.acn.Acn_Dec_Int_PositiveInteger_ConstSize_8UInt8(bs, intVal_Packet_Type_packet_data_kind, 0, 2, result);
            result.ErrorCode := ERR_ACN_DECODE_PACKET_TYPE_PACKET_DATA_KIND;

            if result.Success then
                case intVal_Packet_Type_packet_data_kind is
                    when 0 => Packet_Type_packet_data_kind := setup;
                    when 1 => Packet_Type_packet_data_kind := inputs;
                    when 2 => Packet_Type_packet_data_kind := outputs;
                when others =>																				-- COVERAGE_IGNORE
                    Packet_Type_packet_data_kind := setup;																-- COVERAGE_IGNORE
                    result := adaasn1rtl.ASN1_RESULT'(Success => False, ErrorCode => ERR_ACN_DECODE_PACKET_TYPE_PACKET_DATA_KIND);	-- COVERAGE_IGNORE
                end case;
            else
                Packet_Type_packet_data_kind := setup;																	-- COVERAGE_IGNORE
                result.ErrorCode := ERR_ACN_DECODE_PACKET_TYPE_PACKET_DATA_KIND;																-- COVERAGE_IGNORE
            end if;
            if result.Success then
                -- Decode packet_data
                case Packet_Type_packet_data_kind is
                    when setup =>
                      val.packet_data := Packet_Data_Type'(kind => setup_PRESENT, setup => Setup_Type_Init);
                      Setup_Type_ACN_Decode_aux(val.packet_data.setup, bs, result);

                    when inputs =>
                      val.packet_data := Packet_Data_Type'(kind => inputs_PRESENT, inputs => Inputs_Type_Init);
                      Inputs_Type_ACN_Decode_aux(val.packet_data.inputs, bs, result);

                    when outputs =>
                      val.packet_data := Packet_Data_Type'(kind => outputs_PRESENT, outputs => Outputs_Type_Init);
                      Outputs_Type_ACN_Decode_aux(val.packet_data.outputs, bs, result);

                end case;
                if result.Success then
                    -- Decode Packet_Type_packet_crc32
                    --align to next NextByte
                    if (bs.Current_Bit_Pos mod 8) /= 0 then
                        bs.Current_Bit_Pos := bs.Current_Bit_Pos + (8 - (bs.Current_Bit_Pos mod 8));
                    end if;
                    bitStreamPositions_1.Packet_Type_packet_crc32.Size_In_Bytes := bs.Size_In_Bytes; --save the size of the bit stream
                    bitStreamPositions_1.Packet_Type_packet_crc32.Current_Bit_Pos := bs.Current_Bit_Pos; --save position of the bit stream
                    result.ErrorCode := ERR_ACN_DECODE_PACKET_TYPE_PACKET_CRC32;
                    result.Success := True;
                    bs.Current_Bit_Pos := bs.Current_Bit_Pos + 32;

                    if result.Success then
                        result := postencoding.my_crc_validator(val, bitStreamPositions_start1, bitStreamPositions_1, bs);
                    end if;
                end if;
            end if;
        end if;
    end if;
end Packet_Type_ACN_Decode_aux;
PROCEDURE Packet_Type_ACN_Decode(val: out Packet_Type; Stream : in out Packet_Type_ACN_Stream; result : OUT adaasn1rtl.ASN1_RESULT)
is
begin
    Stream.Current_Bit_Pos :=0;
    Packet_Type_ACN_Decode_aux(val, Stream, result);
    if result.success then
        result := Packet_Type_IsConstraintValid(val);
    end if;

end Packet_Type_ACN_Decode;



function Packet_Data_Kind_Equal (val1, val2 :  Packet_Data_Kind) return Boolean
is

begin
	return val1 = val2;

end Packet_Data_Kind_Equal;

function Packet_Data_Kind_IsConstraintValid(val : Packet_Data_Kind) return adaasn1rtl.ASN1_RESULT
is
    pragma Warnings (Off, "initialization of ""ret"" has no effect");
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ""ret"" has no effect");
begin
    ret.Success := (((((val = setup)) OR ((val = inputs)))) OR ((val = outputs)));
    ret.ErrorCode := (if ret.Success then 0 else ERR_PACKET_DATA_KIND);
    return ret;
end Packet_Data_Kind_IsConstraintValid;



procedure Packet_Data_Kind_ACN_Encode_aux(val : Packet_Data_Kind; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
is
    intVal_val : Interfaces.Unsigned_8;
begin
    result := Packet_Data_Kind_IsConstraintValid(val);
    if result.success and  result.ErrorCode = 0 then
        case val is
            when setup    => intVal_val := 0;
            when inputs    => intVal_val := 1;
            when outputs    => intVal_val := 2;
        end case;
        adaasn1rtl.encoding.uper.UPER_Enc_ConstraintPosWholeNumber(bs, adaasn1rtl.Asn1UInt(intVal_val), 0, 2);
    end if;
end Packet_Data_Kind_ACN_Encode_aux;
procedure Packet_Data_Kind_ACN_Encode(val : Packet_Data_Kind; Stream : out Packet_Data_Kind_ACN_Stream; result : out adaasn1rtl.ASN1_RESULT)
is
begin
    Stream := Packet_Data_Kind_ACN_Stream'(Size_In_Bytes => Packet_Data_Kind_REQUIRED_BYTES_FOR_ACN_ENCODING, Current_Bit_Pos  => 0, pushDataPrm  => 0, fetchDataPrm => 0, Buffer => (others => 0));
    Packet_Data_Kind_ACN_Encode_aux(val, Stream, result);
end Packet_Data_Kind_ACN_Encode;

procedure Packet_Data_Kind_ACN_Decode_aux(val:out Packet_Data_Kind; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
is
    intVal_val : Interfaces.Unsigned_8;
begin
    result.ErrorCode := ERR_ACN_DECODE_PACKET_DATA_KIND;
    adaasn1rtl.encoding.uper.UPER_Dec_ConstraintPosWholeNumberUInt8(bs, intVal_val, 0, 2, 2, result.Success);
    if result.Success then
        case intVal_val is
            when 0 => val := setup;
            when 1 => val := inputs;
            when 2 => val := outputs;
        when others =>																				-- COVERAGE_IGNORE
            val := setup;																-- COVERAGE_IGNORE
            result := adaasn1rtl.ASN1_RESULT'(Success => False, ErrorCode => ERR_ACN_DECODE_PACKET_DATA_KIND);	-- COVERAGE_IGNORE
        end case;
    else
        val := setup;																	-- COVERAGE_IGNORE
        result.ErrorCode := ERR_ACN_DECODE_PACKET_DATA_KIND;																-- COVERAGE_IGNORE
    end if;
end Packet_Data_Kind_ACN_Decode_aux;
PROCEDURE Packet_Data_Kind_ACN_Decode(val: out Packet_Data_Kind; Stream : in out Packet_Data_Kind_ACN_Stream; result : OUT adaasn1rtl.ASN1_RESULT)
is
begin
    Stream.Current_Bit_Pos :=0;
    Packet_Data_Kind_ACN_Decode_aux(val, Stream, result);
    if result.success then
        result := Packet_Data_Kind_IsConstraintValid(val);
    end if;

end Packet_Data_Kind_ACN_Decode;


pragma Warnings (On, "condition can only be False if invalid values present");
pragma Warnings (On, "condition can only be True if invalid values present");

end MCU_COMMS;